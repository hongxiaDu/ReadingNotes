# Java开发

## 基本概述

Java有着严格的类型和权限要求，因此对于类需要考虑权限，类的字段和类的方法需要考虑各自的类型和权限。



### 生命周期

Java对于变量生命周期的管理由==作用域==和==垃圾回收机制==控制，这两种方法分别适用于基本数据类型、对象引用和对象。

Java的作用域是由一对大括号｛｝决定，基本数据类型（包括声明基本数据类型的变量）在作用域范围内有效，超过其作用域范围后无效。然而，对于Java对象而言，Java对象的引用的生命周期是在作用域范围，但是Java对象的生命周期不在作用域范围，而是由垃圾回收机制判别该==new==出来的对象是否还有用，不可用即释放被占用的内存。

举个例子：

```Java
{
    String s = new String("a string")
}
```

引用`s`的生命周期就是作用域范围内，而new出来的字符串对象则不会因超出作用域范围而无效，然而因为指向引用的`s`已经结束了生命，因此无法调用。<span style="color:red">问题是：真的无法调用了吗？</span>

### 关于类

Java的代码必须写在类中，即一个文件就是一个类。

类是对象的外观及行为方式的描述。类是在==new==对象的时候，才被分配存储空间。

==静态==的出现源于两种情况：

1. 多个对象需要共享某个空间
2. 不需要创建对象即可调用方法或者变量

使用==static==关键字满足静态目的，静态意味着使用该字段或者方法不需要依赖于特定的对象实例。

#### 类的权限



#### 构造器

构造器的目的：保证类的初始化。构造器的名称与类名相同，构造器没有返回值，它并不是普通的方法，不能允许有返回值。因为new一个对象本身就会返回该对象，那么构造器如果有返回值，谁来接收呢。这就存在冲突，因此，需要强调，构造器是没有返回值的特殊的方法。

new 的目的有两个：①分配内存，②构造器初始化对象（类没有显式/重载的构造器，也有一个默认构造器/无参构造器）

### 变量类型

#### 成员变量

类的字段，又称为==成员变量==，成员变量可以是基本数据类型和引用数据类型。

基本数据类型在类中作为成员变量定义时，会在类初始化对象的时候自动赋予初始值==变量初始化是Java一个很重要的步骤==。且仅仅是作为类成员变量才有这样的待遇，基本数据类型在作为局部变量使用时，则必须要赋初始值，否则报错。

默认初始值列表如下：

| 基本类型 | 初始值  | 基本类型 | 初始值       |
| -------- | ------- | -------- | ------------ |
| Boolean  | false   | char     | \u0000(null) |
| byte     | (byte)0 | short    | (short)0     |
| int      | 0       | long     | 0L           |
| float    | 0.0f    | double   | 0.0d         |

即使Java的基本数据类型在作为成员变量时，初始化类可以初始化成员变量，但Java依然建议类定义时显示的初始化成员变量。

#### 静态变量

在类中使用`static`关键字声明字段。静态字段使用类名直接调用静态字段。

>问题是：
>
>1. 类中如果声明了静态字段或者静态方法，此时的类是否叫做静态类或者其他？
>2. 如果类中存在静态字段或者静态方法，可以使用类名来直接调用，那么这个类是不是就不能声明普通的成员变量和方法呢？

### 方法类型

Java中方法的基本组成成分：方法名称、参数、返回类型、方法体

```
[返回类型][方法名](/* 参数列表 */) {
	// 方法体
}
```

Java的方法签名：方法名+参数列表。签名是方法的唯一标识。

### 类型转换





## 重要的

### 比较equals

比较对象的内容是否相同，重写类的`equals`方法

### Java安全

#### 数据类型转换

向上数据类型转换时不需要显式转换，一般是无问题的，但是向下数据类型转换，会存在精度丢失的问题，需要额外注意，并且向下数据类型转换时也必须要显示定义转换类型。

#### 溢出

数据计算时要小心溢出，溢出的问题在于每种数据类型是有大小范围的，如果计算结果超出了该类型的数据范围，就会发生溢出。因此，在计算操作时，需要时刻警惕数据类型的范围。

### 重载



































